<!DOCTYPE html>
<html lang="en" class="bg-[#1C1B2E] text-white font-sans">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Lesson</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="config.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0"></script>
</head>

<body class="bg-[#1C1B2E] text-white font-sans">
  <!-- Top Navigation -->
  <div class="fixed top-0 left-0 w-full z-50">
    <div class="flex items-center justify-between px-6 py-4 bg-[#14142B] border-b border-[#2a2a3c]">
      <button onclick="confirmExit()" class="text-sm text-red-400 hover:text-red-600 font-medium">‚úñ Exit</button>
      <div class="flex items-center gap-2">
        <span class="text-sm text-orange-400">‚ù§Ô∏è</span>
        <span id="hearts-value">0</span>
      </div>
    </div>
    <div class="h-2 bg-gray-700">
      <div id="progress-bar" class="h-full bg-[#FFC400] w-0 transition-all duration-300"></div>
    </div>
  </div>

  <!-- Lesson Content -->
  <div id="lesson-container" class="pt-32 px-6 max-w-6xl mx-auto transition-all duration-300"></div>

  <script>
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const urlParams = new URLSearchParams(window.location.search);
    const levelId = urlParams.get("level_id");

    let webcamStream = null;
    let gestureCallback = null;
    let hands, camera;
    let model, gestureLabels;
    let predictionBuffer = [];
    let predictionTimer = null;
    let steps = [], stepIndex = 0;

    async function loadGestureModel() {
      model = await tf.loadLayersModel('/model/model.json');
      const response = await fetch('/model/labels.json');
      gestureLabels = await response.json();
    }

    async function fetchLessonContent() {
      await loadGestureModel();
      const { data: lessons } = await supabase
        .from("lesson")
        .select("id")
        .eq("level_id", levelId)
        .order("order", { ascending: true })
        .limit(1);

      if (!lessons || lessons.length === 0) {
        document.getElementById("lesson-container").innerHTML = "<p>No lesson found for this level.</p>";
        return;
      }

      const lessonId = lessons[0].id;
      const { data: lessonSigns } = await supabase
        .from("lesson_signs")
        .select("*")
        .eq("lesson_id", lessonId)
        .order("order");

      const { data: lessonQuestions } = await supabase
        .from("lesson_questions")
        .select("*")
        .eq("lesson_id", lessonId);

      const usedQuestionIds = new Set();

      // Add each sign and its gesture question
      for (let sign of lessonSigns) {
        steps.push({ type: 'sign', data: sign });

        const relatedGesture = lessonQuestions.find(q =>
          q.type === 'gesture' && q.answer === sign.gloss
        );

        if (relatedGesture) {
          steps.push({ type: 'question', data: relatedGesture });
          usedQuestionIds.add(relatedGesture.id);
        }
      }

      // Add remaining flashcard and multiple-choice questions
      for (let q of lessonQuestions) {
        if ((q.type === 'flashcard' || q.type === 'multiple-choice') && !usedQuestionIds.has(q.id)) {
          steps.push({ type: 'question', data: q });
        }
      }

      renderStep();
    }

    function renderStep() {
      stopWebcam();
      if (stepIndex >= steps.length) {
        document.getElementById("lesson-container").innerHTML = `
          <div class="text-center mt-20">
            <h2 class="text-3xl font-bold mb-4">üéâ Lesson Completed!</h2>
            <button onclick="window.location.href='homepage.html'" class="mt-4 px-6 py-3 bg-green-500 text-white text-lg rounded-lg shadow hover:bg-green-600">Go Home</button>
          </div>
        `;
        return;
      }

      const step = steps[stepIndex];
      const container = document.getElementById("lesson-container");
      container.innerHTML = "";

      const isGesture = step.type === 'sign' || (step.type === 'question' && step.data.type === 'gesture');

      if (isGesture) {
        const isSign = step.type === 'sign';
        const { word, description, video_url, gloss } = isSign ? step.data : {};
        const q = step.data;
        const glossToUse = isSign ? gloss : q.answer;
        const title = isSign ? `Learn: ${word}` : q.question;

        container.innerHTML = `
          <div class="flex flex-col md:flex-row justify-between gap-10 items-center transition-all">
            <div class="w-full md:w-1/2 bg-[#24243A] p-6 rounded-xl shadow-lg">
              <h2 class="text-3xl font-bold text-[#FFC400] mb-4">${title}</h2>
              ${isSign ? `<video src="${video_url}" controls class="w-full rounded mb-4 max-h-64"></video><p class="text-gray-300 text-lg">${description}</p>` : ""}
            </div>
            <div class="w-full md:w-1/2 flex flex-col items-center">
              <video id="webcam" autoplay playsinline class="rounded-xl border border-gray-500 shadow max-w-md w-full aspect-video"></video>
              <div id="gesture-feedback" class="mt-3 text-lg font-semibold text-green-400"></div>
              <button id="tryGestureBtn" class="mt-4 px-6 py-3 text-lg bg-[#FFC400] text-black font-bold rounded-full hover:scale-105 transition">Analyzing...</button>
            </div>
          </div>
        `;

        initWebcam();
        setupMediaPipe();

        setTimeout(() => {
          const btn = document.getElementById("tryGestureBtn");
          btn.innerText = "Try Gesture";
          btn.disabled = false;
          btn.onclick = () => {
            btn.disabled = true;
            btn.innerText = "Analyzing...";
            startGestureSession(glossToUse, success => {
              const feedback = document.getElementById("gesture-feedback");
              if (success) {
                feedback.innerHTML = "‚úÖ <span class='text-green-300'>Correct!</span>";
                btn.innerText = "Continue";
                btn.disabled = false;
                btn.onclick = () => { stepIndex++; renderStep(); };
              } else {
                feedback.innerHTML = "‚ùå <span class='text-red-300'>Try Again.</span>";
                btn.innerText = "Try Again";
                btn.disabled = false;
              }
            });
          };
        }, 600);

      } else if (step.type === 'question') {
        const q = step.data;
        let options = [];
        if (q.choices) {
          try {
            options = typeof q.choices === 'string' ? JSON.parse(q.choices) : q.choices;
          } catch (e) {
            console.error("Invalid choices JSON", e);
          }
        } else {
          console.warn("No choices provided for question:", q);
        }

        container.innerHTML = `
          <div class="text-center max-w-xl mx-auto">
            <h2 class="text-2xl font-bold mb-6">${q.question}</h2>
            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
              ${options.map(opt => `
                <button class="py-3 px-5 bg-gray-700 text-white rounded-lg hover:bg-[#FFC400] hover:text-black transition" onclick="checkAnswer('${opt}', '${q.answer}')">${opt}</button>
              `).join('')}
            </div>
          </div>
        `;
      }

      document.getElementById("progress-bar").style.width = `${Math.floor(((stepIndex + 1) / steps.length) * 100)}%`;
    }

    function checkAnswer(selected, correct) {
      if (selected === correct) {
        stepIndex++;
        renderStep();
      } else {
        alert("Incorrect. Try again.");
      }
    }

    function startGestureSession(expectedGloss, callback) {
      gestureCallback = { expected: expectedGloss, callback };
      predictionBuffer = [];
      if (predictionTimer) clearTimeout(predictionTimer);
      predictionTimer = setTimeout(() => evaluateGesturePrediction(), 2500);
    }

    function onResults(results) {
      if (!gestureCallback || !results.multiHandLandmarks || !model) return;
      const raw = results.multiHandLandmarks[0];
      const input = normalize(raw);
      if (!input) return;
      const prediction = model.predict(tf.tensor([input]));
      prediction.array().then(predictionArray => {
        const maxIndex = predictionArray[0].indexOf(Math.max(...predictionArray[0]));
        const predictedLabel = gestureLabels[maxIndex];
        predictionBuffer.push(predictedLabel);
      });
    }

    function evaluateGesturePrediction() {
      if (!gestureCallback) return;
      const { expected, callback } = gestureCallback;
      const counts = {};
      predictionBuffer.forEach(label => counts[label] = (counts[label] || 0) + 1);
      let topLabel = null, topCount = 0;
      for (const label in counts) {
        if (counts[label] > topCount) {
          topLabel = label;
          topCount = counts[label];
        }
      }
      gestureCallback = null;
      callback(topLabel === expected);
    }

    function initWebcam() {
      const webcamElement = document.getElementById("webcam");
      if (!webcamElement) return;
      if (navigator.mediaDevices?.getUserMedia) {
        navigator.mediaDevices.getUserMedia({ video: true })
          .then(stream => {
            webcamStream = stream;
            webcamElement.srcObject = stream;
          })
          .catch(err => {
            console.error("Failed to acquire camera feed:", err);
            document.getElementById("lesson-container").innerHTML = "<p class='text-red-400'>Unable to access webcam.</p>";
          });
      }
    }

    function stopWebcam() {
      if (webcamStream) webcamStream.getTracks().forEach(track => track.stop());
    }

    function setupMediaPipe() {
      hands = new Hands({ locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
      hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.5 });
      hands.onResults(onResults);
      const videoElement = document.getElementById("webcam");
      if (!videoElement) return;
      camera = new Camera(videoElement, {
        onFrame: async () => await hands.send({ image: videoElement }),
        width: 640,
        height: 480,
      });
      camera.start();
    }

    function normalize(landmarks) {
      if (!landmarks || landmarks.length === 0) return null;
      const base = landmarks[0];
      return landmarks.flatMap(pt => [pt.x - base.x, pt.y - base.y, pt.z - base.z]);
    }

    function confirmExit() {
      if (confirm("Are you sure you want to exit? Your progress will not be saved.")) {
        stopWebcam();
        window.location.href = "homepage.html";
      }
    }

    fetchLessonContent();
  </script>
</body>

</html>