<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Lesson</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="config.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.14.0"></script>
</head>

<body class="bg-[#1C1B2E] text-white font-sans">
  <div class="relative">
    <div class="fixed top-0 left-0 w-full z-50">
      <div class="flex items-center justify-between px-4 py-3 bg-[#14142B] border-b border-[#2a2a3c]">
        <button onclick="confirmExit()" class="text-sm text-red-400 hover:text-red-600">✖ Exit</button>
        <div class="flex items-center gap-3">
          <span class="text-sm text-gray-300">❤️</span>
          <span id="hearts-value">0</span>
        </div>
      </div>
      <div class="h-2 bg-gray-700">
        <div id="progress-bar" class="h-full bg-[#FFC400] w-0 transition-all duration-300"></div>
      </div>
    </div>

    <div id="lesson-container" class="pt-20 px-4 max-w-2xl mx-auto text-center"></div>
  </div>

  <script>
    const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
    const urlParams = new URLSearchParams(window.location.search);
    const levelId = urlParams.get("level_id");

    let webcamStream = null;
    let gestureCallback = null;
    let hands, camera;
    let model, gestureLabels;
    let predictionBuffer = [];
    let predictionTimer = null;

    async function loadGestureModel() {
      model = await tf.loadLayersModel('/model/model.json');
      const response = await fetch('/model/labels.json');
      gestureLabels = await response.json();
      console.log("✅ Model and labels loaded", gestureLabels);
    }

    async function fetchLessonContent() {
      await loadGestureModel();
      const { data: lessons, error } = await supabase
        .from("lesson")
        .select("id")
        .eq("level_id", levelId)
        .order("order", { ascending: true })
        .limit(1);

      if (error) console.error("Error fetching lesson:", error);
      if (!lessons || lessons.length === 0) {
        document.getElementById("lesson-container").innerHTML = "<p>No lesson found for this level.</p>";
        return;
      }

      const lessonId = lessons[0].id;
      const { data: lessonSigns } = await supabase
        .from("lesson_signs")
        .select("*")
        .eq("lesson_id", lessonId)
        .order("order");

      const { data: lessonQuestions } = await supabase
        .from("lesson_questions")
        .select("*")
        .eq("lesson_id", lessonId);

      const interleaved = [];
      for (let i = 0; i < lessonSigns.length; i++) {
        interleaved.push({ type: 'sign', data: lessonSigns[i] });
        const relatedQuestions = lessonQuestions.filter(q => q.answer === lessonSigns[i].gloss);
        if (relatedQuestions.length > 0) {
          interleaved.push({ type: 'question', data: relatedQuestions[0] });
        }
      }

      renderStep(interleaved, 0);
    }

    function renderStep(steps, index) {
      if (index >= steps.length) {
        document.getElementById("lesson-container").innerHTML = "<p>Lesson completed!</p>";
        stopWebcam();
        return;
      }

      const step = steps[index];
      const container = document.getElementById("lesson-container");

      if (step.type === 'sign') {
        const { word, description, video_url, gloss } = step.data;
        container.innerHTML = `
          <h2 class="text-2xl font-bold mb-4">Learn: ${word}</h2>
          <video src="${video_url}" controls class="mx-auto mb-4 max-h-64"></video>
          <p class="mb-4 text-gray-300">${description}</p>
          <div class="mb-4">
            <p class="mb-2 text-sm text-gray-400">Try to perform the sign in front of your camera.</p>
            <div id="gesture-feedback" class="text-green-400 mb-2"></div>
            <video id="webcam" autoplay playsinline class="mx-auto rounded w-full max-w-xs border border-gray-600"></video>
          </div>
          <button id="tryGestureBtn"
            class="px-4 py-2 bg-[#FFC400] text-black rounded">
            I'm Ready, Try My Gesture
          </button>
        `;
        initWebcam();
        setupMediaPipe();

        setTimeout(() => {
          const tryGestureBtn = document.getElementById("tryGestureBtn");
          if (tryGestureBtn) {
            tryGestureBtn.addEventListener("click", () => {
              tryGestureBtn.disabled = true;
              tryGestureBtn.innerText = "⏳ Analyzing...";
              startGestureSession(gloss, () => renderStep(steps, index + 1));
            });
          }
        }, 0);
      }

      document.getElementById("progress-bar").style.width = `${Math.floor(((index + 1) / steps.length) * 100)}%`;
    }

    function handleAnswer(selected, correct, steps, index) {
      if (selected === correct) {
        renderStep(steps, index + 1);
      } else {
        alert("Incorrect. Try again.");
      }
    }

    function initWebcam() {
      const webcamElement = document.getElementById("webcam");
      if (navigator.mediaDevices?.getUserMedia) {
        navigator.mediaDevices.getUserMedia({ video: true })
          .then(function (stream) {
            webcamStream = stream;
            webcamElement.srcObject = stream;
          })
          .catch(function (err) {
            console.error("Webcam error:", err);
            document.getElementById("gesture-feedback").innerText = "Unable to access webcam.";
          });
      }
    }

    function stopWebcam() {
      if (webcamStream) {
        webcamStream.getTracks().forEach(track => track.stop());
      }
    }

    function setupMediaPipe() {
      hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
      });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.5,
      });
      hands.onResults(onResults);

      const videoElement = document.getElementById('webcam');
      camera = new Camera(videoElement, {
        onFrame: async () => {
          await hands.send({ image: videoElement });
        },
        width: 640,
        height: 480,
      });
      camera.start();
    }

    function normalize(landmarks) {
      const base = landmarks[0];
      return landmarks.flatMap(pt => [pt.x - base.x, pt.y - base.y, pt.z - base.z]);
    }

    async function onResults(results) {
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0 && model && gestureCallback) {
        const raw = results.multiHandLandmarks[0];
        const input = normalize(raw);
        const prediction = model.predict(tf.tensor([input]));
        const predictionArray = await prediction.array();
        const maxIndex = predictionArray[0].indexOf(Math.max(...predictionArray[0]));
        const predictedLabel = gestureLabels[maxIndex];

        predictionBuffer.push(predictedLabel);
      }
    }

    function startGestureSession(expectedGloss, onSuccess) {
      gestureCallback = { expected: expectedGloss, onSuccess };
      predictionBuffer = [];

      if (predictionTimer) clearTimeout(predictionTimer);
      predictionTimer = setTimeout(() => {
        evaluateGesturePrediction();
      }, 2000);
    }

    function evaluateGesturePrediction() {
      if (!gestureCallback) return;

      const expected = gestureCallback.expected;
      const count = {};
      predictionBuffer.forEach(label => {
        count[label] = (count[label] || 0) + 1;
      });

      let topLabel = null, topCount = 0;
      for (const label in count) {
        if (count[label] > topCount) {
          topLabel = label;
          topCount = count[label];
        }
      }

      const tryGestureBtn = document.getElementById("tryGestureBtn");
      const feedback = document.getElementById("gesture-feedback");

      if (topLabel === expected) {
        feedback.innerText = `✅ Success!`;
        tryGestureBtn.innerText = "Continue";
        setTimeout(() => gestureCallback.onSuccess(), 1500);
        gestureCallback = null;
      } else {
        feedback.innerText = `❌ Try again.`;
        tryGestureBtn.innerText = "Try Again";
        tryGestureBtn.disabled = false;
        tryGestureBtn.onclick = () => {
          tryGestureBtn.disabled = true;
          tryGestureBtn.innerText = "⏳ Analyzing...";
          startGestureSession(expected, gestureCallback.onSuccess);
        };
      }

      predictionBuffer = [];
    }

    function confirmExit() {
      if (confirm("Are you sure you want to exit? Your progress will not be saved.")) {
        stopWebcam();
        window.location.href = "homepage.html";
      }
    }

    fetchLessonContent();
  </script>
</body>

</html>